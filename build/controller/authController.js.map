{"version":3,"sources":["../../src/controller/authController.js"],"names":["bcrypt","jwt","config","ErrorHandler","verifyToken","Users","checkExisting","JWT_SECRET","getExternalIp","SALT_ROUNDS","authController","login","request","response","next","username","password","reserved","body","check","token","sign","json","success","match","compare","user","findOne","error","register","hash","hashSync","newUser","save","message","verify","decoded","ip"],"mappings":"AAAA,OAAOA,MAAP,MAAmB,QAAnB;AACA,OAAOC,GAAP,MAAgB,cAAhB;AAEA,SAASC,MAAT,QAAuB,cAAvB;AACA,SAASC,YAAT,EAAuBC,WAAvB,QAA0C,yBAA1C;AACA,OAAOC,KAAP,IAAgBC,aAAhB,QAAqC,yBAArC;AAEA,MAAM;AAAEC,EAAAA,UAAF;AAAcC,EAAAA,aAAd;AAA6BC,EAAAA;AAA7B,IAA6CP,MAAnD;AAEA,MAAMQ,cAAc,GAAG;AACnBC,EAAAA,KAAK,EAAE,OAAOC,OAAP,EAAgBC,QAAhB,EAA0BC,IAA1B,KAAmC;AACtC,QAAI;AACA,YAAM;AAAEC,QAAAA,QAAF;AAAYC,QAAAA,QAAZ;AAAsBC,QAAAA;AAAtB,UAAmCL,OAAO,CAACM,IAAjD;;AAEA,UAAI,CAACH,QAAL,EAAe;AACX,cAAM,IAAIZ,YAAJ,CAAiB,GAAjB,EAAsB,oDAAtB,CAAN;AACH;;AAED,UAAI,CAACc,QAAD,IAAaF,QAAjB,EAA2B;AACvB,cAAMI,KAAK,GAAG,MAAMb,aAAa,CAACS,QAAD,CAAjC;;AACA,YAAII,KAAJ,EAAW;AACP,gBAAM,IAAIhB,YAAJ,CAAiB,GAAjB,EAAsB,6EAAtB,CAAN;AACH;;AAED,cAAMiB,KAAK,GAAGnB,GAAG,CAACoB,IAAJ,CAAS;AAAEN,UAAAA,QAAF;AAAYE,UAAAA,QAAQ,EAAE;AAAtB,SAAT,EAAwCV,UAAxC,CAAd;AACA,eAAOM,QAAQ,CAACS,IAAT,CAAc;AAAEC,UAAAA,OAAO,EAAE,IAAX;AAAiBH,UAAAA;AAAjB,SAAd,CAAP;AACH;;AAED,YAAMI,KAAK,GAAG,MAAMxB,MAAM,CAACyB,OAAP,CAAeT,QAAf,EAAyBU,IAAI,CAACV,QAA9B,CAApB;AACA,YAAMU,IAAI,GAAG,MAAMrB,KAAK,CAACsB,OAAN,CAAc;AAAEZ,QAAAA;AAAF,OAAd,CAAnB;;AAEA,UAAIW,IAAI,IAAIF,KAAZ,EAAmB;AACf,cAAMJ,KAAK,GAAGnB,GAAG,CAACoB,IAAJ,CAAS;AAAEN,UAAAA,QAAQ,EAAEW,IAAI,CAACX;AAAjB,SAAT,EAAsCR,UAAtC,CAAd;AACA,eAAOM,QAAQ,CAACS,IAAT,CAAc;AAAEC,UAAAA,OAAO,EAAE,IAAX;AAAiBH,UAAAA;AAAjB,SAAd,CAAP;AACH;;AAED,YAAM,IAAIjB,YAAJ,CAAiB,GAAjB,EAAsB,+CAAtB,CAAN;AACH,KA1BD,CA0BE,OAAOyB,KAAP,EAAc;AACZd,MAAAA,IAAI,CAACc,KAAD,CAAJ;AACH;AACJ,GA/BkB;AAiCnBC,EAAAA,QAAQ,EAAE,OAAOjB,OAAP,EAAgBC,QAAhB,EAA0BC,IAA1B,KAAmC;AACzC,QAAI;AACA,UAAI,CAACF,OAAO,CAACM,IAAb,EAAmB;AACf,cAAM,IAAIf,YAAJ,CAAiB,GAAjB,EAAsB,iBAAtB,CAAN;AACH;;AAED,YAAM;AAAEY,QAAAA,QAAF;AAAYC,QAAAA;AAAZ,UAAyBJ,OAAO,CAACM,IAAvC;AACA,YAAMC,KAAK,GAAG,MAAMb,aAAa,CAACS,QAAD,CAAjC;;AAEA,UAAII,KAAJ,EAAW;AACP,cAAM,IAAIhB,YAAJ,CAAiB,GAAjB,EAAsB,2CAAtB,CAAN;AACH;;AAED,YAAM2B,IAAI,GAAG9B,MAAM,CAAC+B,QAAP,CAAgBf,QAAhB,EAA0BP,WAA1B,CAAb;AACA,YAAMuB,OAAO,GAAG,IAAI3B,KAAJ,CAAU;AAAEU,QAAAA,QAAF;AAAYC,QAAAA,QAAQ,EAAEc;AAAtB,OAAV,CAAhB;AAEA,YAAME,OAAO,CAACC,IAAR,EAAN;AAEA,aAAOpB,QAAQ,CAACS,IAAT,CAAc;AACjBC,QAAAA,OAAO,EAAE,IADQ;AAEjBW,QAAAA,OAAO,EAAE;AAFQ,OAAd,CAAP;AAIH,KArBD,CAqBE,OAAON,KAAP,EAAc;AACZd,MAAAA,IAAI,CAACc,KAAD,CAAJ;AACH;AACJ,GA1DkB;AA4DnBO,EAAAA,MAAM,EAAE,CAACvB,OAAD,EAAUC,QAAV,KAAuB;AAC3B,QAAI,CAACD,OAAO,CAACM,IAAb,EAAmB;AACf,YAAM,IAAIf,YAAJ,CAAiB,GAAjB,EAAsB,gCAAtB,CAAN;AACH;;AAED,UAAM;AAAEiB,MAAAA;AAAF,QAAYR,OAAO,CAACM,IAA1B;AACA,UAAMkB,OAAO,GAAGhC,WAAW,CAACgB,KAAD,CAA3B;;AAEA,QAAI,CAACgB,OAAL,EAAc;AACV,YAAM,IAAIjC,YAAJ,CAAiB,GAAjB,EAAsB,kCAAtB,CAAN;AACH;;AAED,WAAOU,QAAQ,CAACS,IAAT,CAAc;AAAEC,MAAAA,OAAO,EAAE,IAAX;AAAiBa,MAAAA;AAAjB,KAAd,CAAP;AACH,GAzEkB;AA2EnB5B,EAAAA,aAAa,EAAE,OAAOI,OAAP,EAAgBC,QAAhB,KAA6B;AACxC,UAAMwB,EAAE,GAAG,MAAM7B,aAAa,EAA9B;AAEA,WAAOK,QAAQ,CAACS,IAAT,CAAc;AAAEC,MAAAA,OAAO,EAAE,IAAX;AAAiBc,MAAAA;AAAjB,KAAd,CAAP;AACH;AA/EkB,CAAvB;AAkFA,eAAe3B,cAAf","sourcesContent":["import bcrypt from 'bcrypt';\r\nimport jwt from 'jsonwebtoken';\r\n\r\nimport { config } from '../config.js';\r\nimport { ErrorHandler, verifyToken } from '../middlewares/index.js';\r\nimport Users, { checkExisting } from '../models/usersModel.js';\r\n\r\nconst { JWT_SECRET, getExternalIp, SALT_ROUNDS } = config;\r\n\r\nconst authController = {\r\n    login: async (request, response, next) => {\r\n        try {\r\n            const { username, password, reserved } = request.body;\r\n\r\n            if (!username) {\r\n                throw new ErrorHandler(401, 'No username found. Enter a username and try again!');\r\n            }\r\n\r\n            if (!reserved && username) {\r\n                const check = await checkExisting(username);\r\n                if (check) {\r\n                    throw new ErrorHandler(401, 'Username is already in use. Try another username or provide valid password!');\r\n                }\r\n\r\n                const token = jwt.sign({ username, reserved: false }, JWT_SECRET);\r\n                return response.json({ success: true, token });\r\n            }\r\n\r\n            const match = await bcrypt.compare(password, user.password);\r\n            const user = await Users.findOne({ username });\r\n\r\n            if (user && match) {\r\n                const token = jwt.sign({ username: user.username }, JWT_SECRET);\r\n                return response.json({ success: true, token });\r\n            }\r\n\r\n            throw new ErrorHandler(401, 'Username or password is incorrect. Try again!');\r\n        } catch (error) {\r\n            next(error);\r\n        }\r\n    },\r\n\r\n    register: async (request, response, next) => {\r\n        try {\r\n            if (!request.body) {\r\n                throw new ErrorHandler(400, 'Invalid Request');\r\n            }\r\n\r\n            const { username, password } = request.body;\r\n            const check = await checkExisting(username);\r\n\r\n            if (check) {\r\n                throw new ErrorHandler(400, 'Username already exists. Try another one!');\r\n            }\r\n\r\n            const hash = bcrypt.hashSync(password, SALT_ROUNDS);\r\n            const newUser = new Users({ username, password: hash });\r\n\r\n            await newUser.save();\r\n\r\n            return response.json({\r\n                success: true,\r\n                message: 'Successfully registered',\r\n            });\r\n        } catch (error) {\r\n            next(error);\r\n        }\r\n    },\r\n\r\n    verify: (request, response) => {\r\n        if (!request.body) {\r\n            throw new ErrorHandler(401, 'Unauthorized user and/or route');\r\n        }\r\n\r\n        const { token } = request.body;\r\n        const decoded = verifyToken(token);\r\n\r\n        if (!decoded) {\r\n            throw new ErrorHandler(401, 'Unauthorized action. JWT expired');\r\n        }\r\n\r\n        return response.json({ success: true, decoded });\r\n    },\r\n\r\n    getExternalIp: async (request, response) => {\r\n        const ip = await getExternalIp();\r\n\r\n        return response.json({ success: true, ip });\r\n    },\r\n};\r\n\r\nexport default authController;"],"file":"authController.js"}